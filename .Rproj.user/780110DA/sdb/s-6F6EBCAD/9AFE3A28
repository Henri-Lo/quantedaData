{
    "contents" : "#'Constructor for corpus objects\n#'\n#'\n#' This function creates a corpus from a character vector (of texts), \n#' adds text-specific variables (which we term \"attributes\"), along\n#' with optional meta-data and notes.\n#' \n#' @param texts A character vector. This may be either a filepath to a directory containing text documents,\n#' or a character vector containing texts. file.exists checks if it is a valid path\n#' @param docnames Names to be assigned to the texts, defaults to the names of the \n#' character vector (if any), otherwise assigns \"text1\", \"text2\", etc.\n#' @param attribs A data frame of attributes that is associated with each text.\n#' @param attribsIn Specifies if the attributes and values are encoded in file names, directory names, or headers\n#' values are 'filenames', 'dirnames', or 'headers'\n#' @param sep Separator for attribute values if specified in file names or directory names\n#' @param source A string specifying the source of the texts, used for referencing.\n#' @param notes A string containing notes about who created the text, warnings, To Dos, etc.\n#' todo examples\n#' @export\ncorpus <- function(texts, ...){\n  UseMethod(\"corpus\")\n}\n\n\n#' @export\ncorpus.default <- function(){\n  require(tcltk2) \n  texts <- tk_choose.dir()\n  return(corpus.character(texts))\n}\n\n# constructor for simple class representing a directory\n#' @export\ngetDirectory <- function(path){\n  stopifnot(class(path)==\"character\")\n  stopifnot(file.exists(path))\n  tempPath <- path\n  class(tempPath) <- list(\"directory\",class(tempPath))\n  return(tempPath)\n}\n\n\n#' @export\ncorpus.directory<- function(path, docnames=NULL, attribs=NULL, attNames=NULL, sep='_', metadata=NULL, \n                            notes=NULL, citation=NULL){\n  if (!class(path)[1]==\"directory\") stop(\"path must be a directory\")\n  texts <- getTextDir(path)\n  if(class(attribs)=='character'){\n    stopifnot(attribs=='filenames' | attribs=='headers')\n    if(attribs=='filenames'){\n      fnames <- list.files(path, full.names=TRUE)\n      snames <- getRootFileNames(fnames)\n      snames <- gsub(\".txt\", \"\", snames)\n      parts <- strsplit(snames, sep)\n      attributesdf <-  data.frame(matrix(unlist(parts), nrow=length(parts), \n                                         byrow=TRUE), stringsAsFactors=FALSE)\n      if (ncol(attributesdf) != length(attNames)) {\n        stop(\"The length of the parts of the filename does not equal the length of the attribute names\")\n      }\n      names(attributesdf) <- attNames\n      attribs=attributesdf\n    }\n  \n  }\n\n  return(NextMethod(texts=texts, docnames=docnames, attribs=attribs,\n                    metadata=metadata, notes=notes, citation=citation))\n}\n\n\n#' This function creates a corpus from a character vector (of texts), \n#' adds text-specific variables (which we term \"attributes\"), along\n#' with optional meta-data and notes.\n#' \n#' @param texts A character vector containgin\n#' @param docnames Names to be assigned to the texts, defaults to the names of the \n#' character vector (if any), otherwise assigns \"text1\", \"text2\", etc.\n#' @param attribs A data frame of attributes that is associated with each text.\n#' @param source A string specifying the source of the texts, used for referencing.\n#' @param notes A string containing notes about who created the text, warnings, To Dos, etc.\n#' @export\n#' @examples\n#' summary(budgets)\ncorpus.character <- function(texts, docnames=NULL, attribs=NULL,\n                             metadata=NULL, notes=NULL, citation=NULL, ...) {\n  # name the texts vector\n  if (!is.null(docnames)) {\n    stopifnot(length(docnames)==length(texts))\n    names(texts) <- docnames\n  } else if (is.null(names(texts))) {\n    names(texts) <- paste(\"text\", 1:length(texts), sep=\"\")\n  }\n  \n  # create document-meta-data\n  if (is.null(source)) {\n    source <- paste(getwd(), \"/* \", \"on \",  Sys.info()[\"machine\"], \" by \", Sys.info()[\"user\"], sep=\"\")\n  }\n  created <- date()\n  metadata <- c(source=source, created=created, notes=notes, citation=citation)\n  \n  # user-supplied document-level meta-data\n  if (!is.null(attribs)) {\n    stopifnot(nrow(attribs)==length(texts))\n    attribs <- cbind(data.frame(texts, row.names=names(texts), \n                                check.rows=TRUE, stringsAsFactors=FALSE),\n                     data.frame(attribs, row.names=names(texts),\n                                check.rows=TRUE, check.names=TRUE))\n\n  } else {\n    attribs <- data.frame(texts, row.names=names(texts), \n                          check.rows=TRUE, stringsAsFactors=FALSE)\n  }  \n  # build the corpus object\n  tempCorpus <- list(attribs=attribs, \n                      metadata=metadata\n  )\n  class(tempCorpus) <- list(\"corpus\", class(tempCorpus))\n  return(tempCorpus)\n}\n\n# accessor for texts\n#' @export\ntexts <- function(corp){\n  return(unlist(corp$attribs$texts))\n}\n\n# replacement function for texts\n# warning about no data\n#' @export\n\"texts<-\" <- function(corp, value){\n  corp$attribs$texts <- value\n  return(corp)\n}\n\n# accessor for data\n#' @export\ndata <- function(corp){\n  return(corp$attribs[2:length(corp$attribs)])\n}\n\n# replacement function for data\n#' @export\n\"data<-\" <- function(corp, value){\n  corp$attribs[2:length(corp$attribs)]<- value\n  return(corp)\n}\n\n# accessor for tokens\n#' @export\ntokens <- function(corp){\n  return(corp$attribs$tokens)\n}\n\n# replacement function for tokens\n#' @export\n\"tokens<-\" <- function(corp, value){\n  corp$attribs$tokens <- value\n  return(corp)\n}\n\n#' @export\ntypes <- function(corp) {\n  return(unique(unlist(tokens(corp))))\n}\n\n# accessor for docnames\n#' @export\ndocnames <- function(corp){\n  return(names(texts(corp)))\n}\n\n# replacement function for docnames\n#' @export\n\"docnames<-\" <- function(corp, value){\n  names(texts(corp)) <- value\n  return(corp)\n}\n\n# length\n#' @export\nlength.corpus <- function(corp){\n  return(length(texts(corp)))\n}\n\n# accessor for language\n#' @export\nlanguage <- function(corp){\n  return(corp$metadata$language)\n}\n\n# replacement function for language\n#' @export\n\"language<-\" <- function(corp, value){\n  corp$metadata$language <- value\n  return(corp)\n}\n\n# accessor for encoding\n#' @export\nencoding <- function(corp){\n  return(Encoding(corp$texts))\n}\n\n# replacement function for encoding\n#' @export\n\"encoding<-\" <- function(corp, value){\n  texts(corp) <- Encoding(texts(corp), value)\n  return(corp)\n}\n\n#' Corpus sampling\n#'\n#' Takes a random sample of the specified size from a corpus, with or without replacement\n#' \n#' @param corpus An existing corpus to be sampled\n#' @param size A positive number, the number of texts to return\n#' @param replace Should sampling be with replacement?\n#' @param prob Not implemented\n#' @export\n#' @examples\n#' data(movies)\n#' movieSamp <- sample(movies, 200, replace=TRUE)\nsample.corpus <- function(corpus, size=n, replace=FALSE, prob=NULL){\n  if(!is.null(prob)) stop(\"prob argument is not implemented for corpus\")\n  atts <- corpus$attribs\n  sampleInds <- sample(nrow(atts), size=size, replace=replace)\n  newAtts <- atts[sampleInds,]\n  newTexts <- newAtts[[1]]\n  newAtts <- newAtts[2:length(newAtts)]\n  newCorp <- corpusCreate(newTexts, newAtts)\n  newCorp$metadata[\"created\"] <- paste(newCorp$metadata[\"created\"], \"sampled from\",\n                                       corpus$metadata[\"source\"], collapse= \" \")\n  return(newCorp)\n}\n\n#' @export\nprint.corpus <- function(corpus){\n  print(\"Texts (first 20): \\n\")\n  print(paste(substr(texts(corpus)[0:20],0,100), '....'))\n  print(\"Attributes: \\n\")\n  d <- data(corpus)\n  print(d[0:20, 2:ncol(d)])\n}\n\n\ncorpus.subset.inner <- function(corpus, subsetExpr=NULL, selectExpr=NULL, drop=FALSE) {\n  # This is the \"inner\" function to be called by other functions\n  # to return a subset directly, use corpus.subset\n  \n  # The select argument exists only for the methods for data frames and matrices. \n  # It works by first replacing column names in the selection expression with the \n  # corresponding column numbers in the data frame and then using the resulting \n  # integer vector to index the columns. This allows the use of the standard indexing \n  # conventions so that for example ranges of columns can be specified easily, \n  # or single columns can be dropped\n  # as in:\n  # subset(airquality, Temp > 80, select = c(Ozone, Temp))\n  # subset(airquality, Day == 1, select = -Temp)\n  # subset(airquality, select = Ozone:Wind)\n  if (is.null(subsetExpr)) \n    rows <- TRUE\n  else {\n    rows <- eval(subsetExpr, corpus$attribs, parent.frame())\n    if (!is.logical(rows)) \n      stop(\"'subset' must evaluate to logical\")\n    rows <- rows & !is.na(rows)\n  }\n  \n  if (is.null(selectExpr)) \n    vars <- TRUE\n  else {\n    nl <- as.list(seq_along(corpus$attribs))\n    names(nl) <- names(corpus$attribs)\n    vars <- c(1, eval(selectExpr, nl, parent.frame()))\n  }\n  # implement subset, select, and drop\n  corpus$attribs <- corpus$attribs[rows, vars, drop=drop]\n  return(corpus)\n}\n\n\n#' extract a subset of a corpus\n#' \n#' Works just like the normal subset command but for corpus objects\n#' \n#' @param corpus corpus object to be subsetted.\n#' @param subset logical expression indicating elements or rows to keep: missing values are taken as false.\n#' @param select expression, indicating the attributes to select from the corpus\n#' @return corpus object\n#' @export\n#' @examples\n#' \\dontrun{\n#' data(iebudgets)\n#' iebudgets2010 <- subset(iebudgets, year==2010)\n#' summary(iebudgets2010)\n#' iebudgetsLenihan <- subset(iebudgets, speaker=\"Lenihan\", select=c(speaker, year))\n#' summary(iebudgetsLenihan)\n#' }\nsubset.corpus <- function(corpus, subset=NULL, select=NULL) {\n  tempcorp <- corpus.subset.inner(corpus, substitute(subset), substitute(select))\n  return(tempcorp)\n}",
    "created" : 1408015844262.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1407168639",
    "id" : "9AFE3A28",
    "lastKnownWriteTime" : 1409247020,
    "path" : "~/Dropbox/code/quanteda/R/corpus.R",
    "project_path" : "R/corpus.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}